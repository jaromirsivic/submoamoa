Camera 1: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBos()
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=false)
		Width (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Sight Zero: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Attention Zones: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)

Create a new component called “Polygon”. 


Fix (or completely rewrite) the polygon component.
The user will be able to draw a closed polygon using this component. Whenever a user clicks he adds a new point. If a user is in the adding mode and he clicks on the very first point,
the polygon is closed, there will be no more points added to the polygon from this point. User can only move existing points or delete entire polygon and start drawing new one from scratch.
The component is based on the "Image" component with the same set of props (so it can display image behind the polygon) plus following props:
- borderColor: color – color of the polygon line, default value #009900ff
- fillColor: color – color of the inside of the polygon, default value #00ee0055
- lineWidth: number – width of the line in pixels, default value 1px
- maxPoints: identifies how many points can the polygon have, default value is 32.
- polygons: gets or sets an array of polygons, each polygon is identified by array of points. Entire structure is in json format.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the behavior of the "Polygon". Whenever a polygon is closed by clicking on the first point or by
exhausting all points available the polygon should not disapear (current behavior). It must stay where it is
and be infilled with the fillColor. The size of the initial point will be the same as the size of all other
points (currently during drawing mode the size of the very first point is bigger than those of other points
that is OK, but after the polygon is closed the size should be set to the size of other point).
Update Sandbox -> ComponentDemo add a button under each polygon. After clicking the button
the alert message will pop up displaying polygons json. That way I will be able to check if the json is OK.

Update Polygon component. Add following props:
reticleX - x position of the reticle (value between 0 and 1)
reticleY - y position of the reticle (value between 0 and 1)
showReticle - boolean, default value is false
reticleSize - default value is 1
reticleAlpha - default value is 50% or rather 0.5 which means that the reticle is half transparent
reticleColor - color of the reticle, default value is red.
Implement reticle which is displayed if showReticle is true and uses theme like in the picture enclosed to this chat.
Add new examples to the ComponentsDemo page showing various capabilities of reticle.

# ColorPicker
Create a new ColorPicker component. The user will be able to select a color from the color picker, or
specify the color using the hex code. The component should have the following props:
- color: string – the selected color
- onChange: function – the function to be called when the color is changed
- showHex: boolean – whether to show the hex code input or not
- showAlpha: boolean – whether to show the alpha input or not
Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the Polygon component. 
- Remove "reticleAlpha" prop, the alpha channel will be included in "reticleColor".
- add "mode" props. "mode" can be one of: "viewer", "designer", "joystick".
In a viewer mode the user can only see image, polygons
and reticle (of course polygons and reticle will be visible if there are any
polygons and if the showReticle is true). In th "designer" mode the user can draw
polygons. Joystick mode will be implemented later. Do not bother with joystick mode at the moment.

Update the Polygon component.
Implement the "joystick" mode.
In the "joystick" mode user cannot draw or edit polygons.
In the "joystick" mode the user can click on any part of the component.
As soon as he clicks on the image the initial point called static point is displayed as a circle
with color "joystickColor" (default value is #999999cc) and size "joystickSize".
On top of it is another circle called dynamic point again with color "joystickColor" and size "joystickSize".
The centers of the circle are connected with a dotted line of width "joystickLineWidth" (default value is 2).
There will be a "joystickLineMaxLength" prop which will define the maximum length of the line
and therefore maximum distance between the centers of two circles. The default value of "joystickLineMaxLength"
is 0.25 which means that the maximum distance between the centers of two circles is 25% of the image size
computed from the smaller dimension of the image. If the user clicks on the image, moves the mouse or fingertip
while still pressing left mouse button or fingertip - and the distance between the centers of the two circles
is greater than the maximum length, the dynamic point will be placed at the point on the image that is at the
maximum length from the static point and at the same time closest to the clicked point or fingertip.
If the user releases the left mouse button or fingertip the dynamic point will snap to the clicked point
and disappear. The animation length is defined by "joystickSnapAnimationDuration" prop (default value is 0.1s).
Demonstrate the usage of the component in Sandbox -> ComponentDemo page.

Update the Polygon component.
Add event "onJoystickMove". It will be called when the dynamic point moves.
There are x, y parameters of the event object.
The x, y parameters are the coordinates of the dynamic point relative to the static point.
Min value is -1, max value is 1.
Add "joystickLineColor1" prop. It defines the color of the line when the dynamic
point is on top of the static point. Default value is #5555ffff.
Add "joystickLineColor2" prop. It defines the color of the line when the dynamic
point is as far as possible from the static point. Default value is #ff0000ff.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page.
Display x, y coordinates of the dynamic point relative to the static point in the label.


Update the Polygon component.
Add "joystickZeroRadius" prop. It defines the radius of the circle when the
dynamic point is almost on top of the static point. In this case the onJoystickMove event is still
called but the x, y parameters are 0.
Default value is 0.03.

There is a problem with the Slider component on a mobile devices.
I have tried to use the Slider component from the chrome web browser on the mobile phone and it does
not allow me to move slider. I can only click on it. Apparently when i press and hold finger in the browser
(above the slider), the browser thinks I want to scroll the
page and it blocks my attempts to move the slider. Fix the issue.


There is a problem with the Polygon component on a mobile devices.
I have tried to use the Polygon component from the chrome web browser on the mobile phone and it does
not allow me to move move points of polygon. I can only click on it to add a new point.
Apparently when i press and hold finger in the browser
(above the polygon), the browser thinks I want to scroll the
page and it blocks my attempts to move the points of the polygon.
The same applies in the joystick mode.
Fix the issue.

There is still one issue with Polygon component on a mobile devices.
When I am in "joystick" mode and I click and hold the finger on the image
and I do not move it the browser shows me a popup asking me if I want to
download the image. This should not happen. Fix the issue.

There is a problem with the Scene3D component on a mobile devices.
I have tried to use the Scene3D component from the chrome web browser on the mobile phone and it does
not allow me to move the camera. Apparently when I press and hold finger in the browser
(above the Scene3D), the browser thinks I want to scroll the
page and it blocks my attempts to move, rotate or zoom the camera.
Fix the issue.

There is a problem on all pages when they are displayed on a mobile phone.
The top part of the content area is cut off (it is hidden behind Menu Bar).
The bottom part of the content area is cut off (it is hidden behind mobile phone action buttons).
Fix the issue.

Update Settings -> Camera page. The first panel should look like this: 
Camera: Panel()
	Camera Source: Text()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Text()
		Flip Vertically: Text()
		Rotate: Text()
		Crop Left (px): Text()
		Crop Top (px): Text()
		Crop Right (px): Text()
		Crop Bottom (px): Text()
	Resize: HorizontalSeparator()
		Enabled: Text()
		Width (px): Text()
		Height (px): Text()
	Reticle: HorizontalSeparator()
		Show Reticle: Text()
		X (%): Text()
		Y (%): Text()
		Color: ColorPicker(enabled=false)
		Size: Text()

Make all labels of Text component and ColorPicker component bold.
There is an edit button in the header of the panel which displays
a modal window with the following components:

Camera: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): NumericInput(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Y (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Color: ColorPicker()
		Size: NumericInput(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)

There is no interaction with the backend at the moment.

Update Settings -> Camera page
First Panel.
Do not make labels bold. Make bold the values after the ":".
On the model window after the edit button is clicked make the vertical spacing
between the components 0.5rem.
Update modal window using following setup:

Camera: ModalWindow()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Top (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Right (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Bottom (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): Slider(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): Slider(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Y (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Color: ColorPicker()
		Size: Slider(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)
Rename OK button to "Save".

Update Camera -> Settings -> Modal Window:
1. In section "Resize" the "Width (px)" Slider should have a min value 320
2. In section "Resize" the "Height (px)" Slider should have a min value 240
3. In section Flip, Rotate and Crop. All crop sliders should have step 0.25. (two decimal places should be always visible in the NumericInput on the right side of the Slider)
4. In Reticle section the X, Y sliders should have a step 0.1. (two decimal places should be always visible)
5. In Reticle section the Size slider should have a step 0.1. (two decimal places should be always visible)
6. Add a business validation: (Crop Left + Crop Right) < 100
7. Add a business validation (Crop Top + Crop Botton) < 100

Create a Settings -> ImportExport page.
There will be following structure of the gui:

ImportExport: Panel()
	You can import settings from a file (that will override the current settings) or export settings to a file or restore settings to factory defaults.
	Import: HorizontalSeparator()
		Import from file: FileInput()
	Export: HorizontalSeparator()
		Export to file: Button()
	Factory Defaults: HorizontalSeparator()
		Restore Factory Settings: Button()

If user clicks on "Import" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be overriden.
User needs to confirm that.
If user clicks on "Export" button the page will download settings.json.
If user clicks on "Restore Factory Settings" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be restored to factory defaults.
User needs to confirm that.

Create a FileInput component.

On a Settings -> Hot Zone page add an edit button to the Menu Bar on the left side of the menu button.
Use the same style as in the Motors page.
When user clicks on the edit button a modal window should open.

Hot Zone: ModalWindow()
	Units: MultiSwitch(values=["cm", "in"])
	Center Pole: HorizontalSeparator()
		Mic Stick Radius ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		Y Distance from Arm Poles ({unit}): Slider(minValue=-100, maxValue=300, decimalPlaces=1, step=0.1)
	Arm Poles: HorizontalSeparator()
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		X Distance ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
	Arms: HorizontalSeparator()
		Left Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Left Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)

Business validations:
	Left Arm Min Length < Left Arm Max Length
	Right Arm Min Length < Right Arm Max Length

Add a section into the settings.json to store the hot zone settings.
Update backend rest api to store the hot zone settings.
Update backend rest api to get the hot zone settings.

Add following business validations to HotZoneEditModal:
1. Left Arm Min Length < Left Arm Max Length
2. Right Arm Min Length < Right Arm Max Length
Use the same style of warning button and warning logic as it is used on Motors Page.

Create a new file "HotZoneCloudPointsGenerator" with a logic to compute
x, y, z coordinates of cloud points of hot zone. The logic works like this:
1. Create a function to compute intersection of three spheres.
2. Compute a spheres center points:
2a. Left Sphere Center Point is calculated as follows: {
	X = - (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2b. Right Sphere Center Point is calculated as follows: {
	X = (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2c. Top Sphere Center Point is calculated as follows: {
	X = 0
	Y = centerPole.yDistanceFromArmPoles
	Z = centerPole.height
}

In a loop do this:
cloud_points =[]
for i1 in range(0, calculationQuality):
	for i2 in range(0, calculationQuality):
		sphereLeftRadius = arms.leftArmMinLength + (arms.leftArmMaxLength - arms.leftArmMinLength) * i1 / calculationQuality
		sphereRightRadius = arms.rightArmMinLength + (arms.rightArmMaxLength - arms.rightArmMinLength) * i2 / calculationQuality
		sphereCenterRadius = centerPole.micStickRadius
		cloud_points.append(computeIntersectionOfThreeSpheres(leftSphereCenterPoint, rightSphereCenterPoint, centerSphereCenterPoint, sphereLeftRadius, sphereRightRadius, sphereCenterRadius))

When a save button is clicked, the cloud points should be displayed in the Scene3D using blue color.
Previous Scene3D should be cleared.

There should be as well displayed:
- leftPole as a black line of width 4 from:
	(leftSphereCenterPoint.x, leftSphereCenterPoint.y, 0) to (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z)
- rightPole as a black line of width 4 from:
	(rightSphereCenterPoint.x, rightSphereCenterPoint.y, 0) to (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z)
- centerPole as a black line of width 4 from:
	(centerSphereCenterPoint.x, centerSphereCenterPoint.y, 0) to (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z)

On top of each pole there should be displayed an anchor sphere.
Color of left anchor sphere should be red.
Color of right anchor sphere should be green.
Color of center anchor sphere should be blue.

Update HotZoneCloudPointsGenerator.js in a way that it computes the four boundary points.
Boundary points are computed as follows:
Top Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Left Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Bottom Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Right Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Since the Intersection of three spheres can produce multiple points, we need to select the point that is closest to the ground (z coordinate is the smallest).

Update Hot Zone page to display the BoundaryStructure. BoundaryStructure is rendered as a set of lines:
1. Red line of width 0.05 from (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
2. Green line of width 0.05 from (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
3. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
4. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (leftBoundaryPoint.x, leftBoundaryPoint.y, leftBoundaryPoint.z)
5. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (bottomBoundaryPoint.x, bottomBoundaryPoint.y, bottomBoundaryPoint.z)
6. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (rightBoundaryPoint.x, rightBoundaryPoint.y, rightBoundaryPoint.z)

1. When drawing points use red color for those points which have z coordinate smaller than the ground level (z=0)
2. When drawing points use #bbbb00 color for those points which are above the plane defined by topBoundaryPoint, centerSphereCenterPoint, rightBoundaryPoint
or which are above the plane defined by topBoundaryPoint, leftBoundaryPoint and centerSphereCenterPoint

Add a new business validation on the Hot Zone Edit Modal Window to check that all 4 boundary Points exist.
If any of the boundary points do not exist, show a warning message starting with text:
"Invalid Hot Zone Settings. With this setup the motors will not be able to move
from fully retracted position to fully extended position. Please adjust the hot zone settings."

Update Modal Window. Add prop "movable" to the modal window.
When movable is true, the modal window should be movable.
When movable is false, the modal window should not be movable.
Default value of movable is false.

1. Update Hot Zone Modal window. Whenever any Slider value is changed,
meaning mouse up event is triggered, the Scene3D should be updated
but the configuration should not be saved to the settings.json file.
Configuration will be saved only when the Save button is clicked.
2. Update Hot Zone Modal window. The business validation regarding
existence of all 4 boundary points should be treated as an Error.
When the Error is triggered, the Save button should be disabled.
When the Error is cleared, the Save button should be enabled.

Update the Hot Zone. Add two TextFields to the Scene3D to the top left corner.
The first TextField should display the "Horizontal FOV: " value in degrees with two decimal places.
The second TextField should display the "Vertical FOV: " value in degrees with two decimal places.
The horizontal FOV is computed as follows an angle between leftBoundaryPoint, centerSphereCenterPoint and rightBoundaryPoint.
The vertical FOV is computed as follows an angle between topBoundaryPoint, centerSphereCenterPoint and bottomBoundaryPoint.
Create a TextField component if necessary. The TextField component should be used to display text.
It is not an input field, it is just a display field. There should be at least following props:
text: string
fontSize: number
fontColor: string
fontFamily: string
fontStyle: string
fontWeight: string

Update the Scene3D component Reset button which is used to reset the camera position to the default position.
When the Reset button is clicked, the camera position should be reset to the default position.
Default position of camera is (x=200, y=200, z=200). Camera is looking at point (x=0, y=0, z=0).

Create a Table component which should behave like an excel table and will have the following props:
- width: number - optional, by default the width is 100% of parent container
- height: number
- canAddRows: boolean - default false
- canAddColumns: boolean - default false
- canDeleteRows: boolean - default false
- canDeleteColumns: boolean - default false
- maxColumns: number - by default null meaning infinite number of columns. maxColumns is usable only in case that user canAddColumns.
- maxRows: number - by default null meaning infinite number of rows. maxRows is usable only in case that user canAddRows.
- cellsEditable: boolean - by default true
- columnsHeaders: array of objects with properties: name, width, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight - identifying parameter of each column header cell. User cannot override text in header cells. Column header cells are pinned, they do not scroll if vertical scrollbar is used. Similar behavior like in Excel.
- rowsHeaders: array of objects with properties: name, height, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight - identifying parameter of each row header cell. User cannot override text in header cells. Row header cells are pinned, they do not scroll if Horizontal scrollbar is used. Similar behavior like in Excel.
- cells: array of objects with properties: value, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight, editable

RowsHeaders and columnsHeaders can be null.
Cells can be modified by the user. User can select multiple cells, write a number or text and use ctrl+enter to copy the value to all selected cells. Similar behavior like in Excel.
Copy, paste, cut, delete, undo, redo operations are supported.
User can drag the cell by the corner to copy its value - similar behavior as in Excel.
If enabled user can add new rows and columns.

- Cells area of the Table should be scrollable if necessary

Create a new web page in the sandbox and demonstrate the usage of the Table component

Update the table component. There are following issues:
1. When user selects multiple cells either by mouse or by clicking into the cell (lets say cell B1) then holding shift key and selecting another cell (lets say cell B2),
the cells beckground is highlighted correctly, but at the same time web browser highlights/selects as well the text in cells C1, D1, E1, ..., A2, because it probably thinks I want to select, copy and paste a plain text
and it does not recognize that those are different cells and that we are working in the excel like Table. You should correct this behavior so the text in the cells user did not select is not highlighted.
2. Selecting neighboring cells by holding Shift key + arrow key works only for nearest neighboring cell but not for neighbour of the neighbour.
When I press shift + right arrow it selects correctly the right cell from the currently selected cell, but if I press right arrow again nothing happens. The same applies to the top, left and bottom arrows.
3. Remove add buttons for adding new rows and new columns, which are displayed directly in the table. Use context (popup) menu instead.
In the context menu there should be at least following items:
- Copy
- Cut - enabled only if cells are editable, otherwise it is disabled
- Paste
HorizontalSeparator
- Add Column(s) - enabled only if canAddColumns is true. Will add column(s) after the latest selected cell. Typically it adds exactly one column,
but if multiple cells in multiple columns are selected (lets say cells A1, B1, C1, A2, B2, C2) it will add 3 columns after the column C (because cells in three distinct columns are selected and that dictates that 3 columns should be added).
- Add Rows(s) - enabled only if canAddRows is true. Will add row(s) after the latest selected cell. Typically it adds exactly one row,
but if multiple cells in multiple rows are selected (lets say cells A1, B1, C1, A2, B2, C2) it will add 2 rows after the row 2 (because cells in two distinct rows are selected).
- Delete Columns - enabled only if canDeleteColumns is true. Deletes columns of all currently selected cells.
- Delete Rows - enabled only if canDeleteRows is true. Deletes rows of all currently selected cells.



Update the table component. There are following issues:
1. Popup menu used to add rows and columns should be displayed above all other components (to not be cropped by parent panel).
If there is not enough space on the screen to display the menu below mouse cursor, display it above the cursor.
If there is not enough space on the screen to display the menu on the right of mouse cursor, display it on the left of the cursor.
2. Add following props to each column and implement logic for resizing column(s):
- minWidth
- maxWidth
- canResize - default value is false
3. Add following props to each row and implement logic for resizing row(s):
- minHeight
- maxHeight
- canResize - default value is false
4. The area on the bottom right corner of the cell (used when user wants to copy cell into multiple others like in Excel) is too small. Make it at least two times bigger.
5. I was not able to add multiple columns using context menu. The option on all examples is always disabled. May be it is not working.
6. I was not able to delete row or column. The option on all examples is always disabled. May be it is not working.
Fix the issues above and update the Table demo page in the sandbox. Add examples to add columns, rows and to resize columns and rows.


Update the table component. There are following issues:
1. There is a problem with the context menu. When I right click on the cell, the context menu is displayed, but when I click on any enabled option in the context menu, nothing happens.
- Copy, Cut, Paste options are not working.
- User cannot add new rows or columns. The options to add new columns or rows in the context menu are enabled, but when I click on them nothing happens.
- User cannot delete rows or columns. The options to delete columns or rows in the context menu are enabled, but when I click on them nothing happens.
2. The area on the bottom right corner of the cell (used when user wants to copy cell into multiple others like in Excel) is still too small. Make it at least two times bigger.
3. When user uses horizontal scrollbar to scroll the table, the header columns are not scrolled. The header columns should be scrolled as well.
4. Add onChange event to the table component. It should be triggered when user changes any cell value.
5. Add onSelectionChange event to the table component. It should be triggered when user changes selection of cells.
6. Add onAddColumn event to the table component. It should be triggered when user adds new column(s) using context menu.
7. Add onAddRow event to the table component. It should be triggered when user adds new row(s) using context menu.
8. Add onDeleteColumn event to the table component. It should be triggered when user deletes column(s) using context menu.
9. Add onDeleteRow event to the table component. It should be triggered when user deletes row(s) using context menu.
10. Add onResizeColumn event to the table component. It should be triggered when user resizes column(s) using context menu.
11. Add onResizeRow event to the table component. It should be triggered when user resizes row(s) using context menu.
12. Add onCopy event to the table component. It should be triggered when user copies cell(s) value(s) to other cell(s).
13. Add onCut event to the table component. It should be triggered when user cuts cell(s) value(s) to other cell(s).
14. Add onPaste event to the table component. It should be triggered when user pastes cell(s) value(s) to other cell(s).
Demonstrate changes in the sandbox.


NumericInput component when used on a modal window (for example on Settings -> Motors) is not in the same row
as the label. Fix it.

Update the menu component in a way that when the menu is displayed the content area has a gray overlay,
the same way as it is done when the modal window is displayed. When user clicks anywhere 
else except the menu, the menu should be closed.

Update Settings -> Motors page. Edit modal window.
Add new section under the duty cycle section. The section should be named "Speed histogram". There will be following components:
PWM Multiplier: Slider with range from 0 to 1. The value should be rounded to 2 decimal places.
MultiSwitch component. It should have 3 options: Revers, Stop, Forward. The default value should be Stop.
Histogram: Table component. It should have 3 columns: PWM Multiplier, Forward seconds, Reverse seconds.
User is not able to add columns to the table. User can add rows to the table. There should be at most 20 rows in the table.
User can delete rows from the talbe. There must remain at least 2 rows in the table.

Update motors modal window.
1. Inertia should be a slider with range from 0 to 2. The value should be rounded to 2 decimal places.
2. The section "Speed Histogram" should be renamed to "Histogram Quick Test".
3. In section "Histogram Quick Test" and above the Slider "PWM Multiplier" there should be a text:
    Use "PWM Multiplier and "Reverse" / "Forward" buttons to test how long it takes to extend the stroke of linear actuator
    from fully retracted position to fully extended position and vice versa.
4. Before the Table component "Histogram" there should be HorizontalSeparator named "Speed Histogram".

Update the Motors page and rest api to support loading/saving of the motors Histogram data.

1. On the Motors page in the modal window rename "Default State" multiSwitch to "Motor Action".
2. When user clicks in the motors modal window on the "Motor Action" component on "Reverse" or "Forward" button, the application
will call rest api with parameters: "pin_index", "pwm_multiplier". The application will wait for the response
from the rest api and it will reset internal timer called "Histogram Quick Test Timer". The timer should
be reset every time user clicks on the "Reverse" or "Forward" button. The timmer should be stopped when
user clicks on the "Stop" button or when the modal window is closed. 
The timer is updated every 100ms and its value is displayed below the
"Motor Action" MultiSwitch component.
3. On the backend side the action triggers creation and reset of J8 component. The J8[pin_index] should be set to pwm_multiplier.
4. The J8 is reset when user clicks on the "Stop" button or when the modal window is closed. 