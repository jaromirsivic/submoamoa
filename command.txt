Camera 1: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBos()
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=false)
		Width (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Sight Zero: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Attention Zones: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)

Create a new component called “Polygon”. 


Fix (or completely rewrite) the polygon component.
The user will be able to draw a closed polygon using this component. Whenever a user clicks he adds a new point. If a user is in the adding mode and he clicks on the very first point,
the polygon is closed, there will be no more points added to the polygon from this point. User can only move existing points or delete entire polygon and start drawing new one from scratch.
The component is based on the "Image" component with the same set of props (so it can display image behind the polygon) plus following props:
- borderColor: color – color of the polygon line, default value #009900ff
- fillColor: color – color of the inside of the polygon, default value #00ee0055
- lineWidth: number – width of the line in pixels, default value 1px
- maxPoints: identifies how many points can the polygon have, default value is 32.
- polygons: gets or sets an array of polygons, each polygon is identified by array of points. Entire structure is in json format.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the behavior of the "Polygon". Whenever a polygon is closed by clicking on the first point or by
exhausting all points available the polygon should not disapear (current behavior). It must stay where it is
and be infilled with the fillColor. The size of the initial point will be the same as the size of all other
points (currently during drawing mode the size of the very first point is bigger than those of other points
that is OK, but after the polygon is closed the size should be set to the size of other point).
Update Sandbox -> ComponentDemo add a button under each polygon. After clicking the button
the alert message will pop up displaying polygons json. That way I will be able to check if the json is OK.

Update Polygon component. Add following props:
reticleX - x position of the reticle (value between 0 and 1)
reticleY - y position of the reticle (value between 0 and 1)
showReticle - boolean, default value is false
reticleSize - default value is 1
reticleAlpha - default value is 50% or rather 0.5 which means that the reticle is half transparent
reticleColor - color of the reticle, default value is red.
Implement reticle which is displayed if showReticle is true and uses theme like in the picture enclosed to this chat.
Add new examples to the ComponentsDemo page showing various capabilities of reticle.

# ColorPicker
Create a new ColorPicker component. The user will be able to select a color from the color picker, or
specify the color using the hex code. The component should have the following props:
- color: string – the selected color
- onChange: function – the function to be called when the color is changed
- showHex: boolean – whether to show the hex code input or not
- showAlpha: boolean – whether to show the alpha input or not
Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the Polygon component. 
- Remove "reticleAlpha" prop, the alpha channel will be included in "reticleColor".
- add "mode" props. "mode" can be one of: "viewer", "designer", "joystick".
In a viewer mode the user can only see image, polygons
and reticle (of course polygons and reticle will be visible if there are any
polygons and if the showReticle is true). In th "designer" mode the user can draw
polygons. Joystick mode will be implemented later. Do not bother with joystick mode at the moment.

Update the Polygon component.
Implement the "joystick" mode.
In the "joystick" mode user cannot draw or edit polygons.
In the "joystick" mode the user can click on any part of the component.
As soon as he clicks on the image the initial point called static point is displayed as a circle
with color "joystickColor" (default value is #999999cc) and size "joystickSize".
On top of it is another circle called dynamic point again with color "joystickColor" and size "joystickSize".
The centers of the circle are connected with a dotted line of width "joystickLineWidth" (default value is 2).
There will be a "joystickLineMaxLength" prop which will define the maximum length of the line
and therefore maximum distance between the centers of two circles. The default value of "joystickLineMaxLength"
is 0.25 which means that the maximum distance between the centers of two circles is 25% of the image size
computed from the smaller dimension of the image. If the user clicks on the image, moves the mouse or fingertip
while still pressing left mouse button or fingertip - and the distance between the centers of the two circles
is greater than the maximum length, the dynamic point will be placed at the point on the image that is at the
maximum length from the static point and at the same time closest to the clicked point or fingertip.
If the user releases the left mouse button or fingertip the dynamic point will snap to the clicked point
and disappear. The animation length is defined by "joystickSnapAnimationDuration" prop (default value is 0.1s).
Demonstrate the usage of the component in Sandbox -> ComponentDemo page.

Update the Polygon component.
Add event "onJoystickMove". It will be called when the dynamic point moves.
There are x, y parameters of the event object.
The x, y parameters are the coordinates of the dynamic point relative to the static point.
Min value is -1, max value is 1.
Add "joystickLineColor1" prop. It defines the color of the line when the dynamic
point is on top of the static point. Default value is #5555ffff.
Add "joystickLineColor2" prop. It defines the color of the line when the dynamic
point is as far as possible from the static point. Default value is #ff0000ff.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page.
Display x, y coordinates of the dynamic point relative to the static point in the label.


Update the Polygon component.
Add "joystickZeroRadius" prop. It defines the radius of the circle when the
dynamic point is almost on top of the static point. In this case the onJoystickMove event is still
called but the x, y parameters are 0.
Default value is 0.03.

There is a problem with the Slider component on a mobile devices.
I have tried to use the Slider component from the chrome web browser on the mobile phone and it does
not allow me to move slider. I can only click on it. Apparently when i press and hold finger in the browser
(above the slider), the browser thinks I want to scroll the
page and it blocks my attempts to move the slider. Fix the issue.


There is a problem with the Polygon component on a mobile devices.
I have tried to use the Polygon component from the chrome web browser on the mobile phone and it does
not allow me to move move points of polygon. I can only click on it to add a new point.
Apparently when i press and hold finger in the browser
(above the polygon), the browser thinks I want to scroll the
page and it blocks my attempts to move the points of the polygon.
The same applies in the joystick mode.
Fix the issue.

There is still one issue with Polygon component on a mobile devices.
When I am in "joystick" mode and I click and hold the finger on the image
and I do not move it the browser shows me a popup asking me if I want to
download the image. This should not happen. Fix the issue.

There is a problem with the Scene3D component on a mobile devices.
I have tried to use the Scene3D component from the chrome web browser on the mobile phone and it does
not allow me to move the camera. Apparently when I press and hold finger in the browser
(above the Scene3D), the browser thinks I want to scroll the
page and it blocks my attempts to move, rotate or zoom the camera.
Fix the issue.

There is a problem on all pages when they are displayed on a mobile phone.
The top part of the content area is cut off (it is hidden behind Menu Bar).
The bottom part of the content area is cut off (it is hidden behind mobile phone action buttons).
Fix the issue.

Update Settings -> Camera page. The first panel should look like this: 
Camera: Panel()
	Camera Source: Text()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Text()
		Flip Vertically: Text()
		Rotate: Text()
		Crop Left (px): Text()
		Crop Top (px): Text()
		Crop Right (px): Text()
		Crop Bottom (px): Text()
	Resize: HorizontalSeparator()
		Enabled: Text()
		Width (px): Text()
		Height (px): Text()
	Reticle: HorizontalSeparator()
		Show Reticle: Text()
		X (%): Text()
		Y (%): Text()
		Color: ColorPicker(enabled=false)
		Size: Text()

Make all labels of Text component and ColorPicker component bold.
There is an edit button in the header of the panel which displays
a modal window with the following components:

Camera: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): NumericInput(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Y (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Color: ColorPicker()
		Size: NumericInput(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)

There is no interaction with the backend at the moment.

Update Settings -> Camera page
First Panel.
Do not make labels bold. Make bold the values after the ":".
On the model window after the edit button is clicked make the vertical spacing
between the components 0.5rem.
Update modal window using following setup:

Camera: ModalWindow()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Top (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Right (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Bottom (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): Slider(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): Slider(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Y (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Color: ColorPicker()
		Size: Slider(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)
Rename OK button to "Save".

Update Camera -> Settings -> Modal Window:
1. In section "Resize" the "Width (px)" Slider should have a min value 320
2. In section "Resize" the "Height (px)" Slider should have a min value 240
3. In section Flip, Rotate and Crop. All crop sliders should have step 0.25. (two decimal places should be always visible in the NumericInput on the right side of the Slider)
4. In Reticle section the X, Y sliders should have a step 0.1. (two decimal places should be always visible)
5. In Reticle section the Size slider should have a step 0.1. (two decimal places should be always visible)
6. Add a business validation: (Crop Left + Crop Right) < 100
7. Add a business validation (Crop Top + Crop Botton) < 100

Create a Settings -> ImportExport page.
There will be following structure of the gui:

ImportExport: Panel()
	You can import settings from a file (that will override the current settings) or export settings to a file or restore settings to factory defaults.
	Import: HorizontalSeparator()
		Import from file: FileInput()
	Export: HorizontalSeparator()
		Export to file: Button()
	Factory Defaults: HorizontalSeparator()
		Restore Factory Settings: Button()

If user clicks on "Import" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be overriden.
User needs to confirm that.
If user clicks on "Export" button the page will download settings.json.
If user clicks on "Restore Factory Settings" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be restored to factory defaults.
User needs to confirm that.

Create a FileInput component.

On a Settings -> Hot Zone page add an edit button to the Menu Bar on the left side of the menu button.
Use the same style as in the Motors page.
When user clicks on the edit button a modal window should open.

Hot Zone: ModalWindow()
	Units: MultiSwitch(values=["cm", "in"])
	Center Pole: HorizontalSeparator()
		Mic Stick Radius ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		Y Distance from Arm Poles ({unit}): Slider(minValue=-100, maxValue=300, decimalPlaces=1, step=0.1)
	Arm Poles: HorizontalSeparator()
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		X Distance ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
	Arms: HorizontalSeparator()
		Left Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Left Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)

Business validations:
	Left Arm Min Length < Left Arm Max Length
	Right Arm Min Length < Right Arm Max Length

Add a section into the settings.json to store the hot zone settings.
Update backend rest api to store the hot zone settings.
Update backend rest api to get the hot zone settings.

Add following business validations to HotZoneEditModal:
1. Left Arm Min Length < Left Arm Max Length
2. Right Arm Min Length < Right Arm Max Length
Use the same style of warning button and warning logic as it is used on Motors Page.

Create a new file "HotZoneCloudPointsGenerator" with a logic to compute
x, y, z coordinates of cloud points of hot zone. The logic works like this:
1. Create a function to compute intersection of three spheres.
2. Compute a spheres center points:
2a. Left Sphere Center Point is calculated as follows: {
	X = - (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2b. Right Sphere Center Point is calculated as follows: {
	X = (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2c. Top Sphere Center Point is calculated as follows: {
	X = 0
	Y = centerPole.yDistanceFromArmPoles
	Z = centerPole.height
}

In a loop do this:
cloud_points =[]
for i1 in range(0, calculationQuality):
	for i2 in range(0, calculationQuality):
		sphereLeftRadius = arms.leftArmMinLength + (arms.leftArmMaxLength - arms.leftArmMinLength) * i1 / calculationQuality
		sphereRightRadius = arms.rightArmMinLength + (arms.rightArmMaxLength - arms.rightArmMinLength) * i2 / calculationQuality
		sphereCenterRadius = centerPole.micStickRadius
		cloud_points.append(computeIntersectionOfThreeSpheres(leftSphereCenterPoint, rightSphereCenterPoint, centerSphereCenterPoint, sphereLeftRadius, sphereRightRadius, sphereCenterRadius))

When a save button is clicked, the cloud points should be displayed in the Scene3D using blue color.
Previous Scene3D should be cleared.

There should be as well displayed:
- leftPole as a black line of width 4 from:
	(leftSphereCenterPoint.x, leftSphereCenterPoint.y, 0) to (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z)
- rightPole as a black line of width 4 from:
	(rightSphereCenterPoint.x, rightSphereCenterPoint.y, 0) to (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z)
- centerPole as a black line of width 4 from:
	(centerSphereCenterPoint.x, centerSphereCenterPoint.y, 0) to (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z)

On top of each pole there should be displayed an anchor sphere.
Color of left anchor sphere should be red.
Color of right anchor sphere should be green.
Color of center anchor sphere should be blue.

Update HotZoneCloudPointsGenerator.js in a way that it computes the four boundary points.
Boundary points are computed as follows:
Top Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Left Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Bottom Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Right Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Since the Intersection of three spheres can produce multiple points, we need to select the point that is closest to the ground (z coordinate is the smallest).

Update Hot Zone page to display the BoundaryStructure. BoundaryStructure is rendered as a set of lines:
1. Red line of width 0.05 from (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
2. Green line of width 0.05 from (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
3. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
4. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (leftBoundaryPoint.x, leftBoundaryPoint.y, leftBoundaryPoint.z)
5. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (bottomBoundaryPoint.x, bottomBoundaryPoint.y, bottomBoundaryPoint.z)
6. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (rightBoundaryPoint.x, rightBoundaryPoint.y, rightBoundaryPoint.z)

1. When drawing points use red color for those points which have z coordinate smaller than the ground level (z=0)
2. When drawing points use #bbbb00 color for those points which are above the plane defined by topBoundaryPoint, centerSphereCenterPoint, rightBoundaryPoint
or which are above the plane defined by topBoundaryPoint, leftBoundaryPoint and centerSphereCenterPoint

Add a new business validation on the Hot Zone Edit Modal Window to check that all 4 boundary Points exist.
If any of the boundary points do not exist, show a warning message starting with text:
"Invalid Hot Zone Settings. With this setup the motors will not be able to move
from fully retracted position to fully extended position. Please adjust the hot zone settings."

Update Modal Window. Add prop "movable" to the modal window.
When movable is true, the modal window should be movable.
When movable is false, the modal window should not be movable.
Default value of movable is false.

1. Update Hot Zone Modal window. Whenever any Slider value is changed,
meaning mouse up event is triggered, the Scene3D should be updated
but the configuration should not be saved to the settings.json file.
Configuration will be saved only when the Save button is clicked.
2. Update Hot Zone Modal window. The business validation regarding
existence of all 4 boundary points should be treated as an Error.
When the Error is triggered, the Save button should be disabled.
When the Error is cleared, the Save button should be enabled.

Update the Hot Zone. Add two TextFields to the Scene3D to the top left corner.
The first TextField should display the "Horizontal FOV: " value in degrees with two decimal places.
The second TextField should display the "Vertical FOV: " value in degrees with two decimal places.
The horizontal FOV is computed as follows an angle between leftBoundaryPoint, centerSphereCenterPoint and rightBoundaryPoint.
The vertical FOV is computed as follows an angle between topBoundaryPoint, centerSphereCenterPoint and bottomBoundaryPoint.
Create a TextField component if necessary. The TextField component should be used to display text.
It is not an input field, it is just a display field. There should be at least following props:
text: string
fontSize: number
fontColor: string
fontFamily: string
fontStyle: string
fontWeight: string

Update the Scene3D component Reset button which is used to reset the camera position to the default position.
When the Reset button is clicked, the camera position should be reset to the default position.
Default position of camera is (x=200, y=200, z=200). Camera is looking at point (x=0, y=0, z=0).

Create a Table component which should behave like an excel table and will have the following props:
- width: number - optional, by default the width is 100% of parent container
- height: number
- canAddRows: boolean - default false
- canAddColumns: boolean - default false
- canDeleteRows: boolean - default false
- canDeleteColumns: boolean - default false
- maxColumns: number - by default null meaning infinite number of columns. maxColumns is usable only in case that user canAddColumns.
- maxRows: number - by default null meaning infinite number of rows. maxRows is usable only in case that user canAddRows.
- cellsEditable: boolean - by default true
- columnsHeaders: array of objects with properties: name, width, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight - identifying parameter of each column header cell. User cannot override text in header cells. Column header cells are pinned, they do not scroll if vertical scrollbar is used. Similar behavior like in Excel.
- rowsHeaders: array of objects with properties: name, height, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight - identifying parameter of each row header cell. User cannot override text in header cells. Row header cells are pinned, they do not scroll if Horizontal scrollbar is used. Similar behavior like in Excel.
- cells: array of objects with properties: value, align, backgroundColor, textColor, fontSize, fontFamily, fontStyle, fontWeight, editable

RowsHeaders and columnsHeaders can be null.
Cells can be modified by the user. User can select multiple cells, write a number or text and use ctrl+enter to copy the value to all selected cells. Similar behavior like in Excel.
Copy, paste, cut, delete, undo, redo operations are supported.
User can drag the cell by the corner to copy its value - similar behavior as in Excel.
If enabled user can add new rows and columns.

- Cells area of the Table should be scrollable if necessary

Create a new web page in the sandbox and demonstrate the usage of the Table component

Update the table component. There are following issues:
1. When user selects multiple cells either by mouse or by clicking into the cell (lets say cell B1) then holding shift key and selecting another cell (lets say cell B2),
the cells beckground is highlighted correctly, but at the same time web browser highlights/selects as well the text in cells C1, D1, E1, ..., A2, because it probably thinks I want to select, copy and paste a plain text
and it does not recognize that those are different cells and that we are working in the excel like Table. You should correct this behavior so the text in the cells user did not select is not highlighted.
2. Selecting neighboring cells by holding Shift key + arrow key works only for nearest neighboring cell but not for neighbour of the neighbour.
When I press shift + right arrow it selects correctly the right cell from the currently selected cell, but if I press right arrow again nothing happens. The same applies to the top, left and bottom arrows.
3. Remove add buttons for adding new rows and new columns, which are displayed directly in the table. Use context (popup) menu instead.
In the context menu there should be at least following items:
- Copy
- Cut - enabled only if cells are editable, otherwise it is disabled
- Paste
HorizontalSeparator
- Add Column(s) - enabled only if canAddColumns is true. Will add column(s) after the latest selected cell. Typically it adds exactly one column,
but if multiple cells in multiple columns are selected (lets say cells A1, B1, C1, A2, B2, C2) it will add 3 columns after the column C (because cells in three distinct columns are selected and that dictates that 3 columns should be added).
- Add Rows(s) - enabled only if canAddRows is true. Will add row(s) after the latest selected cell. Typically it adds exactly one row,
but if multiple cells in multiple rows are selected (lets say cells A1, B1, C1, A2, B2, C2) it will add 2 rows after the row 2 (because cells in two distinct rows are selected).
- Delete Columns - enabled only if canDeleteColumns is true. Deletes columns of all currently selected cells.
- Delete Rows - enabled only if canDeleteRows is true. Deletes rows of all currently selected cells.



Update the table component. There are following issues:
1. Popup menu used to add rows and columns should be displayed above all other components (to not be cropped by parent panel).
If there is not enough space on the screen to display the menu below mouse cursor, display it above the cursor.
If there is not enough space on the screen to display the menu on the right of mouse cursor, display it on the left of the cursor.
2. Add following props to each column and implement logic for resizing column(s):
- minWidth
- maxWidth
- canResize - default value is false
3. Add following props to each row and implement logic for resizing row(s):
- minHeight
- maxHeight
- canResize - default value is false
4. The area on the bottom right corner of the cell (used when user wants to copy cell into multiple others like in Excel) is too small. Make it at least two times bigger.
5. I was not able to add multiple columns using context menu. The option on all examples is always disabled. May be it is not working.
6. I was not able to delete row or column. The option on all examples is always disabled. May be it is not working.
Fix the issues above and update the Table demo page in the sandbox. Add examples to add columns, rows and to resize columns and rows.


Update the table component. There are following issues:
1. There is a problem with the context menu. When I right click on the cell, the context menu is displayed, but when I click on any enabled option in the context menu, nothing happens.
- Copy, Cut, Paste options are not working.
- User cannot add new rows or columns. The options to add new columns or rows in the context menu are enabled, but when I click on them nothing happens.
- User cannot delete rows or columns. The options to delete columns or rows in the context menu are enabled, but when I click on them nothing happens.
2. The area on the bottom right corner of the cell (used when user wants to copy cell into multiple others like in Excel) is still too small. Make it at least two times bigger.
3. When user uses horizontal scrollbar to scroll the table, the header columns are not scrolled. The header columns should be scrolled as well.
4. Add onChange event to the table component. It should be triggered when user changes any cell value.
5. Add onSelectionChange event to the table component. It should be triggered when user changes selection of cells.
6. Add onAddColumn event to the table component. It should be triggered when user adds new column(s) using context menu.
7. Add onAddRow event to the table component. It should be triggered when user adds new row(s) using context menu.
8. Add onDeleteColumn event to the table component. It should be triggered when user deletes column(s) using context menu.
9. Add onDeleteRow event to the table component. It should be triggered when user deletes row(s) using context menu.
10. Add onResizeColumn event to the table component. It should be triggered when user resizes column(s) using context menu.
11. Add onResizeRow event to the table component. It should be triggered when user resizes row(s) using context menu.
12. Add onCopy event to the table component. It should be triggered when user copies cell(s) value(s) to other cell(s).
13. Add onCut event to the table component. It should be triggered when user cuts cell(s) value(s) to other cell(s).
14. Add onPaste event to the table component. It should be triggered when user pastes cell(s) value(s) to other cell(s).
Demonstrate changes in the sandbox.


NumericInput component when used on a modal window (for example on Settings -> Motors) is not in the same row
as the label. Fix it.

Update the menu component in a way that when the menu is displayed the content area has a gray overlay,
the same way as it is done when the modal window is displayed. When user clicks anywhere 
else except the menu, the menu should be closed.

Update Settings -> Motors page. Edit modal window.
Add new section under the duty cycle section. The section should be named "Speed histogram". There will be following components:
PWM Multiplier: Slider with range from 0 to 1. The value should be rounded to 2 decimal places.
MultiSwitch component. It should have 3 options: Revers, Stop, Forward. The default value should be Stop.
Histogram: Table component. It should have 3 columns: PWM Multiplier, Forward seconds, Reverse seconds.
User is not able to add columns to the table. User can add rows to the table. There should be at most 20 rows in the table.
User can delete rows from the talbe. There must remain at least 2 rows in the table.

Update motors modal window.
1. Inertia should be a slider with range from 0 to 2. The value should be rounded to 2 decimal places.
2. The section "Speed Histogram" should be renamed to "Histogram Quick Test".
3. In section "Histogram Quick Test" and above the Slider "PWM Multiplier" there should be a text:
    Use "PWM Multiplier and "Reverse" / "Forward" buttons to test how long it takes to extend the stroke of linear actuator
    from fully retracted position to fully extended position and vice versa.
4. Before the Table component "Histogram" there should be HorizontalSeparator named "Speed Histogram".

Update the Motors page and rest api to support loading/saving of the motors Histogram data.

1. On the Motors page in the modal window rename "Default State" multiSwitch to "Motor Action".
2. When user clicks in the motors modal window on the "Motor Action" component on "Reverse" or "Forward" button, the application
will call rest api with parameters: "pin_index", "pwm_multiplier". The application will wait for the response
from the rest api and it will reset internal timer called "Histogram Quick Test Timer". The timer should
be reset every time user clicks on the "Reverse" or "Forward" button. The timmer should be stopped when
user clicks on the "Stop" button or when the modal window is closed. 
The timer is updated every 100ms and its value is displayed below the
"Motor Action" MultiSwitch component.
3. On the backend side the action triggers creation and reset of J8 component. The J8[pin_index] should be set to pwm_multiplier.
4. The J8 is reset when user clicks on the "Stop" button or when the modal window is closed. 

Relocate/move the ./package/submoamoa folder and all its content to ./package/src/submoamoa. Be careful to all config files
and dependencies.

It seems that the timer on the modal window in the motors page does not work properly. The logic should be that when user
clicks on the "Reverse" or "Forward" button, the timer should be reset meaning the algorithm will save current datetime.
Then every 100ms the timer should be updated and the difference between the current datetime and the saved datetime should be displayed.
When user clicks on the "Stop" button or when the modal window is closed, the timer should be stopped.

Create a Chart2D component which has the following features:
1. It should have x and y axis.
2. It should have a label for x and y axis.
3. It should have a title.
4. It should have a background color (default white) and a grid (default color light gray) with predefined grid size.
5. It should be pannable if allowed in the props.
6. It should be zoomable if allowed in the props.
7. It should be scrollable if allowed in the props.
8. It should have datasets displayed on the chart.
9. Each dataset can have its own color.
10. Each dataset can have its own label.
11. Each dataset can have its own line width.
12. Each dataset can have its own line style.

Demonstrate usage of the Chart2D component in the sandbox.


1. When zooming the through the chart the grid should zoom as well. There should be a props
with zoom mode which switches the functionality to zoom only the x axis (y is not zoomed)
or the second option as it is implemented right now it will zoom x and y axis.
2. Points should not be visible. When user hovers the mouse near
the line the point should appear and line perpendicular to x and y axis should
appear as well going from the point to axes showing precise numbers of the point coordinates
on the x and y axis.

On the motors page on the panel add a new section named "Histogram" below the section "Duty Cycle". The new section
should have a Chart2D component displaying the speed histogram data.
X axis should have a label "Speed" (from 0 to 1) and Y axis should have a label "PWM Multiplier" (from 0 to 1).
The datasets should be named "Forward" and "Reverse". The datasets should have different colors. Forward will have
blue color and Reverse will have red color. The datasets should have line width of 2.
The datasets will be received via rest api. The rest api endpoint is /api/motors/speedhistogram.
The rest api will load histogram data from assets/settings.json -> motors -> histogram. It will create
a SpeedHistogram object (see speedhistogram.py). Use the loaded histogram from settings.json as a constructor
parameter "speed_histogram". Then use properties "forward_speed_histogram" and "reverse_speed_histogram"
as datasets for the Chart2D component. The datasets should be named "Forward" and "Reverse".

1. The histogram should take 100% width of the parent panel.
2. Currently the Histogram displays two datasets forward and reverse. Use two histograms instead. The first one will display data for forward dataset and the second will display data for reverse dataset. Hide the legend for each Histogram. Use title for the first histogram: "Forward Speed Histogram". Use title for the second histogram: "Reverse Speed Histogram".
3. Make the background of both histograms transparent not white.

Created new web page "General Setup" in the Settings and put it under the "Import / Export". There is one panel
the same style as in the Motors page. There are following text fields on the panel:
Section "Controller Setup"
1. Controller: MultiSwitch component (button1="Localhost Raspberry Pi", button2="Remote pigpio daemon").
By default it is selected "Localhost Raspberry Pi".
2. Remote host: TextField component. By default the address is 192.168.0.1.
3. Remote port: TextField component. By default the port is 8888.
There is an Edit button in the header of the panel (similar like it is on the Motors Page). When user clicks on the Edit button 
the modal window should open. The modal window should have the same style as in the Motors page.
The modal window should have the following components:
1. Controller: MultiSwitch component (button1="Localhost Raspberry Pi", button2="Remote pigpio daemon").
2. Remote host: TextBox component. By default the address is 192.168.0.1.
3. Remote port: NumericInput component(min=0, max=65535). By default the port is 8888.
4. Save button. When user clicks on the Save button the modal window should close. The setup should be saved to settings.json
and the panel should be updated.
If the user selects "Localhost Raspberry Pi" the remote host and remote port should be disabled.

If "Localhost Raspberry Pi" is selected then TextFields on the panel should be disabled and grayed out.
If "Remote pigpio daemon" is selected then TextFields on the panel should be enabled and not grayed out.

1. Update the get_j8 function in main.py to use the remote host and remote port from settings.json.
2. There should be as well a function to reset in the main.py. The reset function will reset j8 with
remote host and remote port from settings.json. The reset function should be called when user clicks
on the "Save" button in the modal window.
3. Take a look into the motors page edit modal window. At the moment the forward and reverse buttons
call backend api which resets the j8. This reset should as well be updated to include 
remote host and remote port from settings.json.
4. If the property "initialized" of the j8 is False after the reset then display a red TextField
on the panel "Controller Setup" with the label "Error: " and the "error_message" of the j8.
5. If the property "initialized" of the j8 is True after the reset then display a green TextField
on the panel "Controller Setup" with the label "Initialized: OK".

Add new business validations to the Motors edit button Modal Window.
There should be following validations for the Speed Histogram table:
1. Table should contain at least two rows.
2. Each cell in the table must be a number with at most 3 decimal places.
3. All values in the column "PWM Multiplier" must be between 0.0 and 1.0.
4. The first row (column "PWM Multiplier") should be 0.0.
5. The last row (column "PWM Multiplier") should be 1.0.
6. All values in the column "Forward sec." and "Reverse sec." must be between 0 and 10000.
7. Each value in the column "PWM Multiplier" at each row except the first one must be greater than the value at the previous row.
8. Each value in the column "Forward sec." at each row except the first one must be lower than the value at the previous row.
9. Each value in the column "Reverse sec." at each row except the first one must be lower than the value at the previous row.
If one or more of the business validations above are not met then user will not be able to save the settings and display
a red Error button. When user clicks on the Error button the red modal window with the error
message should open (same behavior like already implemented with other business validations).
Other already implemented business validations should work the same way and should nicely integrate
with the new business validations.

On the Motors page into the Motors Panel, below the "Inertia" textfield add a new button with text Test Motor.
When user clicks on the Test Motor button the modal window should open.
The modal window should have the same style as in the Motors page.
The modal window should have the following components:
Polygon component with joystick behavior joystickLineMaxLength should be 0.4.
User cannot add any vertices. The reticle is not displayed.
background of the polygon component is joystick_test.svg.
Polygon component will be a square. Width is the same as Modal Window width. Height is the same as width.
Polygon component should be centered in the modal window.

Update Motors page -> edit Modal Window. Change Type and Role components from Combobox to MultiSwitch.

Create a motorscontroller.py file with MotorsController class and necessary methods and functions.
The MotorsController class should
contain a j8 property of type J8, an array of motors created based on settings.json and an execute method
which will be executed
as a separate thread. Inside the execute method there should be an infinite loop which will
call go method of each enabled motor in the array. There will be as well a stop method which will be called
when the MotorsController is stopped or when the FastAPI server is stopped. This method will end the infinite loop
and delete all motors from the array and release the j8. There will be as well a reset method which
will delete all motors from the array, reset the j8 and create new motors based on settings.json.

Update the Settings -> Motors page. In the "Test Motor" modal window If the user uses joystick
and its position changes then send joystick y coordinates to the backend api. The backend api
should call move method of the Motor with the proper motor index and pass
the joystick y coordinates as the speed parameter. Since the coordinates change happens
very often you may keep the connection to the backend api open and send the coordinates
periodically until the joystick is released.

At the moment, when users web browser contacts the sytem it uses port 80 (http).
First it contacts NodeJS server which either responds to the request directly
or in case of rest API requests it forwards the request to the FastAPI server
using port 8000. Why are there two web server instances running on different ports.
FastAPI server according to configuration (line 2: import react from '@vitejs/plugin-react')
should support React. Why is it not used? Everything should run under one web server instance.

1. Update Motors page, "Test Motor" button, Modal Window. Do not use web sockets. Use Rest API
calls when joystick moves. Update as well backend.
2. There should be no text on the modal window. Currently there is:
Use the joystick below to control motor speed directly. Up/Down controls speed (Full extension / Full retraction).
Remove this text.
3. The Polygon component should have same width and height. It should be square. It should cover
the content area of the modal window.

1. Update Motors page, "Test Motor" button, Modal Window. Whenever a joystick is moved
the frontend should call the backend passing motorName not motorIndex. Update the front end and the backend.

Update the Polygon component:
1. Add new props "joystickMoveInterval" where user can specify the interval in miliseconds which
limits how often is the onJoystickMove called. For example if the "joystickMoveInterval" is 500 then
there can be at most two onJoystickMove calls. The "joystickMoveInterval" is non blocking which means
that rendering of joystick is not affected and in case the joysctick moved slightly during the interval
period another onJoystickMove will be triggered. On the other hand if joystick position did not change during
last interval the onJoystickMove will not be triggered. Default value of "joystickMoveInterval" is 0.
2. Add new props "joystickLineMaxLengthMultiplierMode" which defines how the real joystickLineMaxLength is computed.
At the moment the real joystickLineMaxLength is computed out of joystickLineMaxLength props and min(width, height)
of the Polygon component. This mode will be called "minWidthHeight" and it will be a default mode
of the Polygon component. There will be as well mode "width" and mode "height". Mode "width" will take
width of the polygon component into the computation of the real joystickLineMaxLength. Mode "height"
will tak height of the polygon component into the computation of the real joystickLineMaxLength.

Update the Polygon component. There is an issue with onJoystickMove in combination
with "joystickMoveInterval" in case that user is rapidly moving the joystick,
he releases it (so the movement stopped) in between two intervals. Aparently onJoystickEnd is triggered by
the Polygon component but then after the time interval elapses it triggers onJoystickMove event.
Correct behavior is this:
	//user clicks in the Polygon component
	onJoystickStart()
	onJoystickMove(x, y) - triggered when user moves the joystick
	//user releases the joystick
	onJoystickMove(0, 0) - if there was at least one movement after the onJoystickStart
	onJoystickEnd()
	//another onJoystickMove must not be sent here it can be sent only after
	//the user clicks again and it will contain proper coordinates

Update the Polygon component. There is an issue with onJoystickMove after onJoystickEnd was called.
When user mouse up happens (or on the mobile phone he is no longer pressing the screen). There should
be one last onJoystickMove event triggered with x=0, y=0, then onJoystickEnd should be triggered
and then no more onJoystickMoves should be called (unless user starts using joystick again by pressing
mouse button). Animation may still happen even after onJoystickEnd, but that will not trigger onJoystickMove.
Correct behavior of how events are triggered is this:
	//user clicks in the Polygon component
	onJoystickStart()
	//user moves mouse cursor or finger on the screen
	onJoystickMove(x, y)
	//user releases the joystick
	onJoystickMove(0, 0) - if there was at least one movement after the onJoystickStart
	onJoystickEnd()
	//another onJoystickMove must not be sent here even if the snap animation is being rendered.
	//it can be sent only after the user clicks again and starts moving the mouse

Update Settings -> Camera page:
We will start the design of this page from the scratch.
There will be three panels on the page.
The first panel is called "Camera". There will be following components on the panel:
- General Setup: HorizontalSeparator
- - Input Device Index: TextField(value=0)
- - Preferred resolution: TextField(value=1920 x 1080)
- - Accepted Resolution: TextField(1920 x 1080)
- Flip and Rotate: HorizontalSeparator
- - Flip Horizontally: Switch
- - Flip Vertically: Switch
- - Rotate (degrees): Combobox(possible values=[0, 90, 180, 270], value=0)
- Preview: HorizontalSeparator
- - Live Preview: Polygon(image=blank)
- - Show Full Screen: Button
The second panel is called "Manual Control - Input Img". There will be following components on the panel:
- Crop: HorizontalSeparator
- - Top: TextField(value="0% (0 pixels)")
- - Left: TextField(value="0% (0 pixels)")
- - Bottom: TextField(value="0% (0 pixels)")
- - Right: TextField(value="0% (0 pixels)")
- Stretch: HorizontalSeparator
- - Width: TextField(value="640 pixels")
- - Height: TextField(value="480 pixels")
- Preview: HorizontalSeparator
- - Live Preview: Polygon(image=blank)
- - Show Full Screen: Button
The second panel is called "AI Agent - Input Img". There will be following components on the panel:
- Crop: HorizontalSeparator
- - Top: TextField(value="0% (0 pixels)")
- - Left: TextField(value="0% (0 pixels)")
- - Bottom: TextField(value="0% (0 pixels)")
- - Right: TextField(value="0% (0 pixels)")
- Stretch: HorizontalSeparator
- - Width: TextField(value="640 pixels")
- - Height: TextField(value="480 pixels")
- Attention Area: HorizontalSeparator
- - Attention Area Enabled: Switch
- - Attention Area Polygon: Polygon(image=blank)
- - Show Full Screen: Button

Update camera page.
1. For each panel in the page create an Edit button in the header of the panel.
The same approach as on the Motors page. When user clicks on the Edit button
a Modal Window will appear. There will be appropriate input controls in the window.
2. On the Camera page in all panels change the TextBox components, Switch components
and ComboBox components to plain TextFields (the Same approach and style like on the Motors page)
3. Fix the following issue. When user tries to navigate to another page from the Camera page
nothing happens. He still remains on the Camera page. Fix it.

There are following issues on the Camera Page:
1. When I click on the Menu Button in the Menu and then when I click on the Main Page
the Main Page is not displayed, the url in the browser changes but I still see Camera page,
there must be something wrong with the single page application that it does not render
main page correctly and stays on the Camera Page.
Expected behavior: the Main Page is displayed.

Create a new web page Cameras.jsx. It will be placed in the menu just below the "Camera" row
and its label will be "Camera(s)". The page will look almost like the "Camera" page, except
there will be no "Preview" section in the first and second panel and no "Attention Area" in the third panel.
Those sections should be removed as well from the Modal Windows.
Make sure that user can correctly navigate to this page and from this page through the menu.
Update all necessary files to add this new page.

Update Cameras page -> Camera Panel -> edit button -> Modal Window:
1. There should be no "Accepted Resolution" displayed in the Modal Window.
2. Input Device and Preferred Resolution should be ComboBoxes
3. There is a horizontal scrollbar displayed in the modal window.
Probably the width of some components is too big. Make them smaller so the horizontal scroll bar will
disapear.

For each property mentioned in camerascontroller -> Camera._load_properties
create a property in the Camera class. Getter will look like this:
@property
def brightness(self) -> int:
    return self.camera.get(cv2.CAP_PROP_BRIGHTNESS)

Setter will look like this:
@brightness.setter
def brightness(self, value: int):
    self.camera.set(cv2.CAP_PROP_BRIGHTNESS, value)

Remove web page Camera.jsx. Delete the file, remove the route, delete backend api if there is any.

Update the "Slider" component. At the moment slider has "min" and "max" props which define the range of the slider
and as well range of the "NumericInput" component. There will be created "minSlider" and "maxSlider" props
which will define the range of the slider. Those will be min and max boundaries of the slider.
But the "NumericInput" component will still have "min" and "max" props as a boundaries for the value.
If "minSlider" or "maxSlider" are not defined, then "min" and "max" props will be used as boundaries for the slider.

Update the Camera web page. Add all Camera properties to the Camera -> Edit -> Modal Window. Do not add
those properties to the Camera -> Panel. The Camera -> Panel should only display the properties that are
visible to the user at the moment. The Modal Window should display all properties.
Now do not create any backend logic for the Camera properties. Just update the frontend.

Update Camera web page. All sliders should have allowManualInput prop set to true. All
sliders (the sliding part without caption and NumericInput) 
in the section "Image Settings" should be optically aligned and should have the same width.
There must be no horizontal scrollbar displayed in the modal window. Probably the width of some components is too big.
Make them smaller so the horizontal scroll bar will disapear.

Update all basic components which have label prop. Add labelWidth prop to all of them so we can control
the width of the label to align components.

Update Camera web page. All sliders in the "Controls" section should have allowManualInput prop set to true.
All components should be optically aligned. Optical alignment is done per section - in each section
the components (sliders, switches, comboboxes, ...) should be aligned to the same left position
(I am not talking about the labels, but about the input part of the components) 
and the same kind of components (again not labels, but the input part of the components) should have the same width.

Add gap: '1rem' to other components (if it is relevant). We should have the same gap between components.
We should always maintain the same strategy and same look and feel for the components.

1. Update the Camera web page. Values in the Camera Panel and on the Camera -> Edit -> Modal Window should
be loaded from the backend. Backend should return all properties of the Camera class stored in the settings.json
camera -> general section.
Some properties like "Input Device Index" and "Preferred Resolution" are comboboxes which have
list of possible values. Backend should create a list of those values by reading all available input devices
(stored in main.py -> master_controller -> cameras_controller -> cameras -> name) and supported_resolutions
(stored in main.py -> master_controller -> cameras_controller -> cameras -> supported_resolutions) and dynamically
create a structure like this:
{
    "input_devices": [
        {
            "value": 0,
            "label": "Input Device 0"
			"supported_resolutions": [
				{
					"width": 640,
					"height": 480,
					"label": "640 x 480"
				},
				{
					"width": 1280,
					"height": 720,
					"label": "1280 x 720"
				}
			]
        },
        {
            "value": 1,
            "label": "Input Device 1"
			"supported_resolutions": [
				{
					"width": 640,
					"height": 480,
					"label": "640 x 480"
				},
				{
					"width": 1280,
					"height": 720,
					"label": "1280 x 720"
				}
			]
        }
    ]
}
and incorporate this structure into the message sent to the frontend.
Do not bother with saving the properties to the backend at the moment. Focus only on loading the properties from the backend.

Update the Camera web page. Rename "Preferred Resolution" to "Resolution". Rename "Input Device Index" to "Input Device".
Resolution should change when Input Device changes. List of resolutions should be loaded
from the "supported_resolutions" property which was sent by the backend to the frontend. If there is no
item in the list, then the ComboBox will have only one item "0 x 0".

Update camera web page. Add a new section "Preview" to the Camera Panel.
There should be following components in the section:
	Enabled: Switch
	Live Preview: Polygon
The Polygon component is stretched to fill the entire width of the section/panel.
The height of the Polygon component is computed based on the "4/3" aspect ratio.
If the enabled switch is off, then the "assets/camera.svg" should be displayed in the Polygon component
in the fit mode. The polygon should be optically aligned with the camera image.
Do not implement any backend logic for the Preview section at the moment.

The Polygon component added to the Cameras web page line 279-285 is causing a routing issues.
When the Polygon was added to the Cameras web page whenever user clicks on any other item in the menu
trying to navigate out of the page, nothing happens. Url in the web browser changes
but then nothing happens. The user is stuck on the Camera web page.
When the Polygon component is removed the routing starts to work correctly.
Find the issue and fix it. I need ot use Polygon component on this page.

The issue was not fixed by your changes. But I have found what can
remove the issue. If I add polygons={polygons1}
(see line 286) the routing issue dissapears. Why? Can you fix the root cause?

Update camera web page. Add a new section "Preview" 
to the "Manual Control - Input Img." and "AI Agent - Input Img." panels.
There should be following components in the section:
	Enabled: Switch
	Live Preview: Polygon
The Polygon component is stretched to fill the entire width of the section/panel.
The height of the Polygon component is computed based on the "4/3" aspect ratio.
If the enabled switch is off, then the "assets/camera.svg" should be displayed in the Polygon component
in the fit mode. The polygon should be optically aligned with the camera image.
Do not implement any backend logic for the Preview section at the moment.

Update Camera web page. When user enables preview in the camera panel the Polygon component
should display live video/image feed of the camera from the backend. Source of the feed is:
master_controller.cameras_controller.cameras[camera_index].image.frame
camera_index is saved in settings.json -> cameras -> general -> deviceIndex
Update Cameras.jsx, Polygon.jsx, main.py and other files if necessary.

Update Camera web page. When user enables preview in the "Manual Control - Input Img." panel the Polygon component
should display live video/image feed of the camera from the backend. Source of the feed is:
master_controller.cameras_controller.cameras[camera_index].image_cropped_resized.frame
camera_index is saved in settings.json -> cameras -> general -> deviceIndex

Update Camera web page. When user enables preview in the "AI Agent - Input Img." panel the Polygon component
should display live video/image feed of the camera from the backend. Source of the feed is:
master_controller.cameras_controller.cameras[camera_index].image_ai.frame
camera_index is saved in settings.json -> cameras -> general -> deviceIndex

On the Camera page on the Modal Window of the Camera Panel add following components:
Into the section general setup add:
FPS: Slider (minvalue=1, maxvalue=240)

On the Camera web page on the left side of the edit button in the header of the Camera panel add
a reload button with icon ./assets/reload.svg. When user clicks on 
the reload button the yes/no Modal Window with a question:
	Do you want to refresh list of camera devices? This operation may take several seconds.
If the user clicks on the "yes" button all displayed live streams in the Preview section
of all panels are terminated and "Enabled" switches in those Preview sections are turned off. The Backend api /reset is called
and the master_controller.cameras_controller.reset() function is called.

When user clicks on the Reload button on the Camera web page and then clicks
on the yes button on the Modal Window the button should change color and be disabled
and a text "Saving..." should appear. The same behavior like on the General Setup
web page should be used.

Split main.py into several files:
for example all rest api calls and all logic regarding motors should be placed into restapimotors.py
all rest api calls and all logic regarding camreas should be placed into restapicameras.py
and so on.
Each page will have its restapi{pagename}.py file

Update Camera web page -> Camera panel Modal Window and restapicameras.py -> /api/cameras/list.
Modify current behavior in the rest api. Currently we are returning back from the get_cameras_list_endpoint()
only the list of device names and for each device only a list of supported resolutions.
In the updated version we will return full list of all properties
of each camera using camera.to_dict() function. We will then load and display those properties
on the Modal Window - components for each property should already be there.

1. Update Camera web page. The get_cameras_list_endpoint() now almost returns correct json. The json looks like this:
{
    "controllerSetup": {
        "controller": "remote",
        "remoteHost": "192.168.68.56",
        "remotePort": 8888
    },
    "input_devices": [
        {
            "index": 0,
            "name": "0: GUID_1.0",
            "supported_resolutions": [
                {
                    "width": 320,
                    "height": 240,
                    "label": "320 x 240"
                },
                {
                    "width": 640,
                    "height": 480,
                    "label": "640 x 480"
                },
                {
                    "width": 1280,
                    "height": 720,
                    "label": "1280 x 720"
                },
                {
                    "width": 1920,
                    "height": 1080,
                    "label": "1920 x 1080"
                }
            ],
            "width": 1920,
            "height": 1080,
            "fps": 30.0,
            "bitrate": -1.0,
            "buffer_size": 1.0,
            "flip_horizontal": false,
            "flip_vertical": false,
            "rotate": 0,
            "brightness": 128.0,
            "contrast": 32.0,
            "hue": 0.0,
            "saturation": 64.0,
            "sharpness": 3.0,
            "gamma": 120.0,
            "white_balance_temperature": -1.0,
            "backlight_compensation": 1.0,
            "gain": -1.0,
            "focus": -1.0,
            "exposure": -6.0,
            "auto_white_balance_temperature": true,
            "auto_focus": true,
            "auto_exposure": false,
            "value": 0,
            "label": "0: GUID_1.0"
        },
		...
In the "input_devices" structure get rid of "value" and "label" those are redundant information.
If Cameras.jsx needs them then remap it to "index" and "name".

2. Make sure that the inputs in the Modal Window which are displayed after user clicks on the edit button in the Camera panel
are correctly set based on the last result of rest api call /api/cameras/list. For example brightness is correctly returned
as 128 in the json but the value of "Brightness" Slider in the section "Image Settings" in the Modal Window
is 0. There must be some error. Fix it.

Update Cameras web page I know where is the issue with the Modal Window. If the user selects
another input device and then goes back to the input device with index 0 the inputs in the Modal window
are set to correct values. It seems that the first display of the Modal Window does not refresh
all inputs and there are some default values but not the values based on the json received from backend.
Fix it.

1. Update Camera web page -> edit button -> Modal Window. Add "Apply" button between
Save and Cancel button. Apply button should have the same color as Save button.
1b. Remove "Accepted Resolution" TextField from the Camera panel and put "FPS" instead.
2. Create a backend function /api/cameras/savecamera to handle "save" and "apply" actions:
2a. When Apply button is pressed the setup of each camera (which could have been modified by
the user when interacting with properrties of the cameras in the modal window)
is sent back to the backend. Backend sets up "settings" property of all
cameras in the master_controller.cameras_controller.cameras[CAMERA_INDEX].settings and returns true to the front end.
Front end then immediately calls /api/cameras/list and refreshes all inputs on the modal window.
Nothing is saved to the settings.json. Modal window is not closed.
2b. When save button is pressed the behavior is almost the same as when the Apply button was pressed
except this time the setup of all cameras is saved into the settings.json
for each camera into the settings.json -> cameras[CAMERA_INDEX].general. then the Modal
window is closed. Rest api to list cameras is called but this time only to update the textfields of the Camera panel.

Add a Preview section into the Camera -> Edit -> Modal window as the last section of the Modal Window.
There will be a Polygon component in the section
connected to the camera live feed in the same way like it is done on the Camera panel
except here it is always enabled and immediately consumes a camera live feed. When the modal is closed
the preview on the Modal window stops consuming live feed.
The preview is not mentioned in the jsons exchanged with the backend. It exists only temporarily on the Modal Window.

The preview section with the Polygon on the Camera -> Edit -> Modal Window should 
display the live feed only in case the Enabled switch in the Preview section on the
Camera panel is turned on. Otherwise there should be displayed the same icon
as in the Camera panel and live feed is not consumed.

1. Add a preview section into the Manual Control - Input Img -> Modal Window. The behavior should be analogous
to the behavior of the Preview section in the Camera -> Modal Window.
2. Add a preview section into the AI Agent - Input Img -> Modal Window. The behavior should be analogous
to the behavior of the Preview section in the Camera -> Modal Window.

Update Camera web page -> edit button -> Modal window. When user changes "Input Device"
all live feeds in all polygons (on modal windows and as well in panels) should be stopped.
Then those live feeds which are enabled should be started again this time with different input device id.

Update Camera web page -> edit button -> Modal window. When user changes "Resolution"
all live feeds in all polygons (on modal windows and as well in panels) should be stopped.
Then those live feeds which are enabled should be started again.

Update reset button functionallity.
When user clicks on a reset button in the header of Camera panel and presses a yes button
for all cameras the master_controller.cameras_controller.cameras[CAMERA_INDEX].reset_settings() should
be called and cameras.general section of each camera should be deleted in settings.json

Update the reset button functionallity on the Cameras web page.
When the reset is finished call /api/cameras/list and update
values of input components on all panels and in Modal Windows.
