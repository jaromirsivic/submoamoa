Camera 1: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBos()
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=false)
		Width (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Sight Zero: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Attention Zones: HorizontalSeparator()
		X (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Y (px): NumericInput(minValue=0, decimalPlaces=0, step=1)

Create a new component called “Polygon”. 


Fix (or completely rewrite) the polygon component.
The user will be able to draw a closed polygon using this component. Whenever a user clicks he adds a new point. If a user is in the adding mode and he clicks on the very first point,
the polygon is closed, there will be no more points added to the polygon from this point. User can only move existing points or delete entire polygon and start drawing new one from scratch.
The component is based on the "Image" component with the same set of props (so it can display image behind the polygon) plus following props:
- borderColor: color – color of the polygon line, default value #009900ff
- fillColor: color – color of the inside of the polygon, default value #00ee0055
- lineWidth: number – width of the line in pixels, default value 1px
- maxPoints: identifies how many points can the polygon have, default value is 32.
- polygons: gets or sets an array of polygons, each polygon is identified by array of points. Entire structure is in json format.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the behavior of the "Polygon". Whenever a polygon is closed by clicking on the first point or by
exhausting all points available the polygon should not disapear (current behavior). It must stay where it is
and be infilled with the fillColor. The size of the initial point will be the same as the size of all other
points (currently during drawing mode the size of the very first point is bigger than those of other points
that is OK, but after the polygon is closed the size should be set to the size of other point).
Update Sandbox -> ComponentDemo add a button under each polygon. After clicking the button
the alert message will pop up displaying polygons json. That way I will be able to check if the json is OK.

Update Polygon component. Add following props:
reticleX - x position of the reticle (value between 0 and 1)
reticleY - y position of the reticle (value between 0 and 1)
showReticle - boolean, default value is false
reticleSize - default value is 1
reticleAlpha - default value is 50% or rather 0.5 which means that the reticle is half transparent
reticleColor - color of the reticle, default value is red.
Implement reticle which is displayed if showReticle is true and uses theme like in the picture enclosed to this chat.
Add new examples to the ComponentsDemo page showing various capabilities of reticle.

# ColorPicker
Create a new ColorPicker component. The user will be able to select a color from the color picker, or
specify the color using the hex code. The component should have the following props:
- color: string – the selected color
- onChange: function – the function to be called when the color is changed
- showHex: boolean – whether to show the hex code input or not
- showAlpha: boolean – whether to show the alpha input or not
Demonstrate the usage of the component in Sandbox -> ComponentDemo page

Update the Polygon component. 
- Remove "reticleAlpha" prop, the alpha channel will be included in "reticleColor".
- add "mode" props. "mode" can be one of: "viewer", "designer", "joystick".
In a viewer mode the user can only see image, polygons
and reticle (of course polygons and reticle will be visible if there are any
polygons and if the showReticle is true). In th "designer" mode the user can draw
polygons. Joystick mode will be implemented later. Do not bother with joystick mode at the moment.

Update the Polygon component.
Implement the "joystick" mode.
In the "joystick" mode user cannot draw or edit polygons.
In the "joystick" mode the user can click on any part of the component.
As soon as he clicks on the image the initial point called static point is displayed as a circle
with color "joystickColor" (default value is #999999cc) and size "joystickSize".
On top of it is another circle called dynamic point again with color "joystickColor" and size "joystickSize".
The centers of the circle are connected with a dotted line of width "joystickLineWidth" (default value is 2).
There will be a "joystickLineMaxLength" prop which will define the maximum length of the line
and therefore maximum distance between the centers of two circles. The default value of "joystickLineMaxLength"
is 0.25 which means that the maximum distance between the centers of two circles is 25% of the image size
computed from the smaller dimension of the image. If the user clicks on the image, moves the mouse or fingertip
while still pressing left mouse button or fingertip - and the distance between the centers of the two circles
is greater than the maximum length, the dynamic point will be placed at the point on the image that is at the
maximum length from the static point and at the same time closest to the clicked point or fingertip.
If the user releases the left mouse button or fingertip the dynamic point will snap to the clicked point
and disappear. The animation length is defined by "joystickSnapAnimationDuration" prop (default value is 0.1s).
Demonstrate the usage of the component in Sandbox -> ComponentDemo page.

Update the Polygon component.
Add event "onJoystickMove". It will be called when the dynamic point moves.
There are x, y parameters of the event object.
The x, y parameters are the coordinates of the dynamic point relative to the static point.
Min value is -1, max value is 1.
Add "joystickLineColor1" prop. It defines the color of the line when the dynamic
point is on top of the static point. Default value is #5555ffff.
Add "joystickLineColor2" prop. It defines the color of the line when the dynamic
point is as far as possible from the static point. Default value is #ff0000ff.

Demonstrate the usage of the component in Sandbox -> ComponentDemo page.
Display x, y coordinates of the dynamic point relative to the static point in the label.


Update the Polygon component.
Add "joystickZeroRadius" prop. It defines the radius of the circle when the
dynamic point is almost on top of the static point. In this case the onJoystickMove event is still
called but the x, y parameters are 0.
Default value is 0.03.

There is a problem with the Slider component on a mobile devices.
I have tried to use the Slider component from the chrome web browser on the mobile phone and it does
not allow me to move slider. I can only click on it. Apparently when i press and hold finger in the browser
(above the slider), the browser thinks I want to scroll the
page and it blocks my attempts to move the slider. Fix the issue.


There is a problem with the Polygon component on a mobile devices.
I have tried to use the Polygon component from the chrome web browser on the mobile phone and it does
not allow me to move move points of polygon. I can only click on it to add a new point.
Apparently when i press and hold finger in the browser
(above the polygon), the browser thinks I want to scroll the
page and it blocks my attempts to move the points of the polygon.
The same applies in the joystick mode.
Fix the issue.

There is still one issue with Polygon component on a mobile devices.
When I am in "joystick" mode and I click and hold the finger on the image
and I do not move it the browser shows me a popup asking me if I want to
download the image. This should not happen. Fix the issue.

There is a problem with the Scene3D component on a mobile devices.
I have tried to use the Scene3D component from the chrome web browser on the mobile phone and it does
not allow me to move the camera. Apparently when I press and hold finger in the browser
(above the Scene3D), the browser thinks I want to scroll the
page and it blocks my attempts to move, rotate or zoom the camera.
Fix the issue.

There is a problem on all pages when they are displayed on a mobile phone.
The top part of the content area is cut off (it is hidden behind Menu Bar).
The bottom part of the content area is cut off (it is hidden behind mobile phone action buttons).
Fix the issue.

Update Settings -> Camera page. The first panel should look like this: 
Camera: Panel()
	Camera Source: Text()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Text()
		Flip Vertically: Text()
		Rotate: Text()
		Crop Left (px): Text()
		Crop Top (px): Text()
		Crop Right (px): Text()
		Crop Bottom (px): Text()
	Resize: HorizontalSeparator()
		Enabled: Text()
		Width (px): Text()
		Height (px): Text()
	Reticle: HorizontalSeparator()
		Show Reticle: Text()
		X (%): Text()
		Y (%): Text()
		Color: ColorPicker(enabled=false)
		Size: Text()

Make all labels of Text component and ColorPicker component bold.
There is an edit button in the header of the panel which displays
a modal window with the following components:

Camera: Panel()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Top (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Right (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
		Crop Bottom (px): NumericInput(minValue=0, decimalPlaces=0, step=1)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): NumericInput(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): NumericInput(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Y (%): NumericInput(value=50, minValue=0, maxValue=100, decimalPlaces=3, step=0.5)
		Color: ColorPicker()
		Size: NumericInput(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)

There is no interaction with the backend at the moment.

Update Settings -> Camera page
First Panel.
Do not make labels bold. Make bold the values after the ":".
On the model window after the edit button is clicked make the vertical spacing
between the components 0.5rem.
Update modal window using following setup:

Camera: ModalWindow()
	Camera Source: ComboBox()
	Flip, Rotate and Crop: HorizontalSeparator()
		Flip Horizontally: Switch(value=no)
		Flip Vertically: Switch(value=no)
		Rotate: ComboBox(values=["0", "90", "180", "270"])
		Crop Left (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Top (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Right (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Crop Bottom (%): Slider(minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
	Resize: HorizontalSeparator()
		Enabled: switch(value=true)
		Width (px): Slider(value=640, minValue=0, decimalPlaces=0, step=1)
		Height (px): Slider(value=480, minValue=0, decimalPlaces=0, step=1)
	Reticle: HorizontalSeparator()
		Show Reticle: Switch(value=true)
		X (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Y (%): Slider(value=50, minValue=0, maxValue=100, decimalPlaces=2, step=0.5)
		Color: ColorPicker()
		Size: Slider(minValue=0.25, maxValue=5, decimalPlaces=2, step=0.25)
Rename OK button to "Save".

Update Camera -> Settings -> Modal Window:
1. In section "Resize" the "Width (px)" Slider should have a min value 320
2. In section "Resize" the "Height (px)" Slider should have a min value 240
3. In section Flip, Rotate and Crop. All crop sliders should have step 0.25. (two decimal places should be always visible in the NumericInput on the right side of the Slider)
4. In Reticle section the X, Y sliders should have a step 0.1. (two decimal places should be always visible)
5. In Reticle section the Size slider should have a step 0.1. (two decimal places should be always visible)
6. Add a business validation: (Crop Left + Crop Right) < 100
7. Add a business validation (Crop Top + Crop Botton) < 100

Create a Settings -> ImportExport page.
There will be following structure of the gui:

ImportExport: Panel()
	You can import settings from a file (that will override the current settings) or export settings to a file or restore settings to factory defaults.
	Import: HorizontalSeparator()
		Import from file: FileInput()
	Export: HorizontalSeparator()
		Export to file: Button()
	Factory Defaults: HorizontalSeparator()
		Restore Factory Settings: Button()

If user clicks on "Import" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be overriden.
User needs to confirm that.
If user clicks on "Export" button the page will download settings.json.
If user clicks on "Restore Factory Settings" button, the system should ask for confirmation, informing user that current settings of Motors, Camera, AI, ... will be restored to factory defaults.
User needs to confirm that.

Create a FileInput component.

On a Settings -> Hot Zone page add an edit button to the Menu Bar on the left side of the menu button.
Use the same style as in the Motors page.
When user clicks on the edit button a modal window should open.

Hot Zone: ModalWindow()
	Units: MultiSwitch(values=["cm", "in"])
	Center Pole: HorizontalSeparator()
		Mic Stick Radius ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		Y Distance from Arm Poles ({unit}): Slider(minValue=-100, maxValue=300, decimalPlaces=1, step=0.1)
	Arm Poles: HorizontalSeparator()
		Height ({unit}): Slider(minValue=0, maxValue=300, decimalPlaces=1, step=0.1)
		X Distance ({unit}): Slider(minValue=10, maxValue=300, decimalPlaces=1, step=0.1)
	Arms: HorizontalSeparator()
		Left Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Left Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Min Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)
		Right Arm Max Length ({unit}): Slider(minValue=1, maxValue=300, decimalPlaces=1, step=0.1)

Business validations:
	Left Arm Min Length < Left Arm Max Length
	Right Arm Min Length < Right Arm Max Length

Add a section into the settings.json to store the hot zone settings.
Update backend rest api to store the hot zone settings.
Update backend rest api to get the hot zone settings.

Add following business validations to HotZoneEditModal:
1. Left Arm Min Length < Left Arm Max Length
2. Right Arm Min Length < Right Arm Max Length
Use the same style of warning button and warning logic as it is used on Motors Page.

Create a new file "HotZoneCloudPointsGenerator" with a logic to compute
x, y, z coordinates of cloud points of hot zone. The logic works like this:
1. Create a function to compute intersection of three spheres.
2. Compute a spheres center points:
2a. Left Sphere Center Point is calculated as follows: {
	X = - (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2b. Right Sphere Center Point is calculated as follows: {
	X = (armPoles.xDistance / 2)
	Y = 0
	Z = armPoles.height
}
2c. Top Sphere Center Point is calculated as follows: {
	X = 0
	Y = centerPole.yDistanceFromArmPoles
	Z = centerPole.height
}

In a loop do this:
cloud_points =[]
for i1 in range(0, calculationQuality):
	for i2 in range(0, calculationQuality):
		sphereLeftRadius = arms.leftArmMinLength + (arms.leftArmMaxLength - arms.leftArmMinLength) * i1 / calculationQuality
		sphereRightRadius = arms.rightArmMinLength + (arms.rightArmMaxLength - arms.rightArmMinLength) * i2 / calculationQuality
		sphereCenterRadius = centerPole.micStickRadius
		cloud_points.append(computeIntersectionOfThreeSpheres(leftSphereCenterPoint, rightSphereCenterPoint, centerSphereCenterPoint, sphereLeftRadius, sphereRightRadius, sphereCenterRadius))

When a save button is clicked, the cloud points should be displayed in the Scene3D using blue color.
Previous Scene3D should be cleared.

There should be as well displayed:
- leftPole as a black line of width 4 from:
	(leftSphereCenterPoint.x, leftSphereCenterPoint.y, 0) to (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z)
- rightPole as a black line of width 4 from:
	(rightSphereCenterPoint.x, rightSphereCenterPoint.y, 0) to (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z)
- centerPole as a black line of width 4 from:
	(centerSphereCenterPoint.x, centerSphereCenterPoint.y, 0) to (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z)

On top of each pole there should be displayed an anchor sphere.
Color of left anchor sphere should be red.
Color of right anchor sphere should be green.
Color of center anchor sphere should be blue.

Update HotZoneCloudPointsGenerator.js in a way that it computes the four boundary points.
Boundary points are computed as follows:
Top Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Left Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMinLength and center sphere with radius centerPole.micStickRadius.
Bottom Boundary Point is computed as intersection of Left Sphere with radius leftArmMinLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Right Boundary Point is computed as intersection of Left Sphere with radius leftArmMaxLength and Right Sphere with radius rightArmMaxLength and center sphere with radius centerPole.micStickRadius.
Since the Intersection of three spheres can produce multiple points, we need to select the point that is closest to the ground (z coordinate is the smallest).

Update Hot Zone page to display the BoundaryStructure. BoundaryStructure is rendered as a set of lines:
1. Red line of width 0.05 from (leftSphereCenterPoint.x, leftSphereCenterPoint.y, leftSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
2. Green line of width 0.05 from (rightSphereCenterPoint.x, rightSphereCenterPoint.y, rightSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
3. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (topBoundaryPoint.x, topBoundaryPoint.y, topBoundaryPoint.z)
4. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (leftBoundaryPoint.x, leftBoundaryPoint.y, leftBoundaryPoint.z)
5. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (bottomBoundaryPoint.x, bottomBoundaryPoint.y, bottomBoundaryPoint.z)
6. Blue line of width 0.05 from (centerSphereCenterPoint.x, centerSphereCenterPoint.y, centerSphereCenterPoint.z) to (rightBoundaryPoint.x, rightBoundaryPoint.y, rightBoundaryPoint.z)

1. When drawing points use red color for those points which have z coordinate smaller than the ground level (z=0)
2. When drawing points use #bbbb00 color for those points which are above the plane defined by topBoundaryPoint, centerSphereCenterPoint, rightBoundaryPoint
or which are above the plane defined by topBoundaryPoint, leftBoundaryPoint and centerSphereCenterPoint

Add a new business validation on the Hot Zone Edit Modal Window to check that all 4 boundary Points exist.
If any of the boundary points do not exist, show a warning message starting with text:
"Invalid Hot Zone Settings. With this setup the motors will not be able to move
from fully retracted position to fully extended position. Please adjust the hot zone settings."

Update Modal Window. Add prop "movable" to the modal window.
When movable is true, the modal window should be movable.
When movable is false, the modal window should not be movable.
Default value of movable is false.

1. Update Hot Zone Modal window. Whenever any Slider value is changed,
meaning mouse up event is triggered, the Scene3D should be updated
but the configuration should not be saved to the settings.json file.
Configuration will be saved only when the Save button is clicked.
2. Update Hot Zone Modal window. The business validation regarding
existence of all 4 boundary points should be treated as an Error.
When the Error is triggered, the Save button should be disabled.
When the Error is cleared, the Save button should be enabled.

Update the Hot Zone. Add two TextFields to the Scene3D to the top left corner.
The first TextField should display the "Horizontal FOV: " value in degrees with two decimal places.
The second TextField should display the "Vertical FOV: " value in degrees with two decimal places.
The horizontal FOV is computed as follows an angle between leftBoundaryPoint, centerSphereCenterPoint and rightBoundaryPoint.
The vertical FOV is computed as follows an angle between topBoundaryPoint, centerSphereCenterPoint and bottomBoundaryPoint.
Create a TextField component if necessary. The TextField component should be used to display text.
It is not an input field, it is just a display field. There should be at least following props:
text: string
fontSize: number
fontColor: string
fontFamily: string
fontStyle: string
fontWeight: string


